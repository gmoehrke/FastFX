<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FastFX: FastFX library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FastFX
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Flexible LED Strip Animation with FastLED</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">FastFX library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="markdown-FastFX%20library"></a></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Table of Contents</h1>
<p><a class="anchor" id="markdown-Table%20of%20Contents"></a></p>
<ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#overview">Overview</a></li>
<li><a href="#model">Model</a></li>
<li><a href="#tutorial--examples">Tutorial &amp; Examples</a><ul>
<li><a href="#firstlight">FirstLight</a><ul>
<li><a href="#cycle-and-phase">Cycle and Phase</a></li>
<li><a href="#initialization">Initialization</a></li>
<li><a href="#speed-and-cross-fade">Speed and Cross-fade</a></li>
<li><a href="#movementtype">MovementType</a></li>
<li><a href="#color">Color</a></li>
</ul>
</li>
<li><a href="#firstlight-2">FirstLight 2</a><ul>
<li><a href="#segments">Segments</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Overview</h1>
<p><a class="anchor" id="markdown-Overview"></a></p>
<p>FastFX is an Arduino library that builds on the FastLED library for creating effects and animations for LED Strips. The principle idea behind the library is to provide a set of reusable classes/objects to create and display multiple colors/animations/etc. consistently in any sketch. Effects are written as classes/subclasses and displayed by a common controller object. By defining effects as objects, FastFX is able to provide capabilities that are common to all effects without the need to custom code them for each individual effect. These capabilities include:</p>
<ul>
<li>Automatic crossfade between "frames" - useful for smoother transitions in slower moving sequences.</li>
<li>Automatic crossfade between effects - gradual fade between effects when changing from one effect to another</li>
<li>Segments - Multiple effects shown in different segments of the same Strip</li>
<li>Transparency - One effect shown over the top of another with variable transparency (while both continue to animate)</li>
<li>Common Color/Palette Management - Color object/interface to change the look of effects without custom coding each color/combination</li>
<li>Independent timing - Each effect maintains its own independent Timer</li>
<li>Overlay Sequences - Brief animation sequences that can be show over the top of looping effects (with variable transparency). Useful for indicating events, transitions, etc. <br  />
</li>
<li>Auto-faders for dimming and transparency - allows for smooth transitions when changing brightness and/or transparency levels. Timing can be set independently for each. <br  />
</li>
</ul>
<h1><a class="anchor" id="autotoc_md3"></a>
Model</h1>
<p><a class="anchor" id="markdown-Model"></a></p>
<p>The programming model for using FastFX differs slightly from coding directly with FastLED. The following is a brief description of the classes needed to create a sketch using FastFX:</p>
<p><img src="images/FFX_Classes.jpg" alt="classes" class="inline"/></p>
<ul>
<li><b><a class="el" href="class_f_f_x_base.html">FFXBase</a></b> - Each effect is written as a subclass of the <a class="el" href="class_f_f_x_base.html">FFXBase</a> class. <a class="el" href="class_f_f_x_base.html">FFXBase</a> has its own timing parameters that determine how many milliseconds each "frame" will last. The smaller the interval, the faster the animation. <a class="el" href="class_f_f_x_base.html">FFXBase</a> provides two virtual methods that may be overridden. The most important is the WriteNextFrame() method. This method is used to make changes to a FastLED CRGB array (*CRGB[]) that represents the pixels to draw. The FastFX framework includes several pre-built effect classes, including the default <a class="el" href="class_solid_f_x.html">SolidFX</a> class, which represents a single static color (see FXXCoreEffects.h)</li>
<li><p class="startli"><b><a class="el" href="class_f_f_x_segment.html">FFXSegment</a></b> - A single LED strip is represented by a set of one or more segments. Each strip contains a <em>Primary</em> segment, which represents the entire strip. If effects will only be displayed along the entire strip, this is the only segment that needs to be present. If multiple effects are desired, then additional <em>secondary</em> segments may be defined. These segments may each have a different effect and each has its own <em>opacity</em> setting (0-255, 0=100% transparent, 255=100% opaque). The secondary segments do not need to cover the entire length of the primary segment. Pixels in the primary segment will always be visible unless they are covered by a secondary segment (and the secondary segment's opacity is greater than 0).</p>
<p class="startli">Each secondary segment is given a name or <em>Tag</em>, which is used to reference that segment on the controller. The controller provides 2 methods to access the individual segments - getPrimarySegment() and findSegment(String tag), each returns a pointer to the appropriate segment. Note that these pointers can be dereferenced safely without checking for NULLs, if an invalid segment name is specified for findSegment, a pointer to the primary segment will be returned. <br  />
 <img src="images/segments.jpg" alt="segments" class="inline"/> </p><pre class="fragment">Each segment maintains a FFXFrameProvider object that is responsible for returning the frames to be drawn for each update.  The frame provider manages the cross fading, allocating extra buffers when needed.
</pre></li>
<li><b><a class="el" href="class_f_f_x_controller.html">FFXController</a></b> - This is the main interface for the FastFX framework. Every FastFX sketch will create an <a class="el" href="class_f_f_x_controller.html">FFXController</a> object and then use that object to define segments, start/stop effects and set various other parameters (brightness, opacity, speed, etc).</li>
</ul>
<h1><a class="anchor" id="autotoc_md4"></a>
Tutorial &amp; Examples</h1>
<p><a class="anchor" id="markdown-Tutorial%20%26%20Examples"></a></p>
<h2><a class="anchor" id="autotoc_md5"></a>
FirstLight</h2>
<p><a class="anchor" id="markdown-FirstLight"></a></p>
<p>Since each effect is a standalone class, creating a new one is a straightforward task. Taking from the "FirstLight" example code in the FastLED library, we will create a FastFX version and see how we gain additional functionality with FastFX. First we'll construct the effect class, which is always a descendant of <a class="el" href="class_f_f_x_base.html">FFXBase</a>:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">class FirstLightFX : public FFXBase {</div>
<div class="line">  public:    </div>
<div class="line">    // Constructor - provides defaults for interval, minInterval, and maxInterval</div>
<div class="line">    FirstLightFX(uint16_t initSize) : FFXBase( initSize, 10UL, 10UL, 100UL ) {</div>
<div class="line">      // currColor holds the FFXColor object used to manage colors in effects - this is a</div>
<div class="line">      // simple single-color effect using RGB colors, so we set the mode to singleCRGB</div>
<div class="line">      currColor.setColorMode( FFXColor::FXColorMode::singleCRGB );</div>
<div class="line">      // then supply it the color</div>
<div class="line">      currColor.setCRGB( CRGB::White );</div>
<div class="line">      // effect is running on a segment of the strip.</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    // Override initLeds - this method is called only once, right before the first frame is drawn</div>
<div class="line">    // Note that anything done here is not &quot;shown&quot; until after the first call to writeNextFrame()</div>
<div class="line">    virtual void initLeds( CRGB *bufLeds ) override {</div>
<div class="line">      // Clear the field</div>
<div class="line">      fill_solid( bufLeds, getNumLeds(), CRGB::Black );      </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    // Override writeNextFrame - this is what is called for each change.  Note that the controller</div>
<div class="line">    // will only call this once for each frame, so we don&#39;t need to track anything about the Timing</div>
<div class="line">    // or coordination with other effects...just write the frame data into the passed CRGB array</div>
<div class="line">    virtual void writeNextFrame( CRGB *bufLeds ) override {</div>
<div class="line">      // fade any lit pixels to leave a trail behind the moving colored pixel</div>
<div class="line">      fadeToBlackBy( bufLeds, numLeds, 50 );</div>
<div class="line">      // set the next pixel to the current value in our FFXColor object (white, in this case)</div>
<div class="line">      bufLeds[getCurrPhase()-1] = currColor.getCRGB();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md6"></a>
Cycle and Phase</h3>
<p><a class="anchor" id="markdown-Cycle%20and%20Phase"></a></p>
<p>Note the use of <code>getCurrPhase()</code> here. All effects have running counters for <em>Phase</em> and <em>Cycle</em>. The Phase counter starts at 1, and increments for each step until it reaches the number of pixels covered by that effect. This is considered one cycle. Once a cycle is completed, the phase is reset to 1. The <code>getCurrCycle()</code> method returns the count of how many times this has been repeated. For an effect running at an interval of 10 (milliseconds) with 100 pixels, a single phase will take 10 milliseconds, while a full cycle will take 1 second (1000 milliseconds). <br  />
</p>
<p>Note that the use of Phase and Cycle in implementing effects is not mandatory. An effect can completely ignore them and still be 100% functional. They simply provide some convenient reference points and can be very useful for calculating motion and timing when used appropriately.</p>
<h3><a class="anchor" id="autotoc_md7"></a>
Initialization</h3>
<p><a class="anchor" id="markdown-Initialization"></a></p>
<p>For FastLED, we need the CRGB array that represents the pixels in our strip, and we will also need a <a class="el" href="class_f_f_x_controller.html">FFXController</a> object for FastFX. So, the following 2 globals are defined:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">CRGB leds[NUM_LEDS]</div>
<div class="line">FFXController fxctrlr = FFXController();</div>
</div><!-- fragment --><p>Now we can modify the setup() function to create and initialize an instance of the <a class="el" href="class_f_f_x_controller.html">FFXController</a>, and create and add the effect to the controller:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">void setup() {</div>
<div class="line">    pinMode( 5, OUTPUT );</div>
<div class="line">    FastLED.addLeds&lt;WS2811, DATA_PIN, GRB&gt;(leds, NUM_LEDS);</div>
<div class="line">    FastLED.clear();</div>
<div class="line"> </div>
<div class="line">    fxctrlr.initialize( new FFXFastLEDPixelController( leds, NUM_LEDS ) );</div>
<div class="line">    fxctrlr.getPrimarySegment()-&gt;setFX( new FirstLightFX( NUM_LEDS ) );</div>
<div class="line">    fxctrlr.getPrimarySegment()-&gt;setBrightness( 100 );</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now that we've built all of the instructions for creating the effect into our FirstLightFX class and added it to the controller, the main loop simply needs to make sure the controller continues to run:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">void loop() {</div>
<div class="line">  fxctrlr.update();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The full code can be found in <a href="examples/FFXFirstLight_1.ino">examples/FFXFirstLight_1.ino</a>. <br  />
</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Speed and Cross-fade</h3>
<p><a class="anchor" id="markdown-Speed%20and%20Cross-fade"></a></p>
<p>When running this example, note that you may select a different interval value to control the speed of the animation. Thas may be done by calling: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">fxctrlr.getPrimarySegment()-&gt;getFX().setInterval( newInterval );</div>
</div><!-- fragment --><p>The interval may be changed any time after creating the effect. By using a larger interval (200+ milliseconds), you may notice that the leading white dot fades in over the duration of that interval to make the animation smoother. This is because crossfading is enabled by default by the framework. The extra buffers and frame-blending are all done automatically. This can be disabled on any individual effect by calling </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">fxctrlr.getPrimarySegment()-&gt;getFrameProvider()-&gt;setCrossFade(false)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md9"></a>
MovementType</h3>
<p><a class="anchor" id="markdown-MovementType"></a></p>
<p>In the above example, the movement is uni-directional - in only goes from low to high and starts over. All FastFX effect have a MovementType setting, which can be set using <code>setMovement( MovementType )</code> and inspected using <code>getMovement()</code>. This may be used to support more flexible patterns of motion without having to code each individually. The Phase of the effect can be inspected normally through <code>getCurrPhase()</code>, but it may also be interpreted through <code>getMovementPhase()</code>, which will interpret the Phase in respect to the MovementType setting on the effect as follows:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">MovementType </th><th class="markdownTableHeadNone">MovementPhase  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MVT_FORWARD </td><td class="markdownTableBodyNone">The phase increments normally and resets to 1 at the end of each cycle.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">MVT_BACKWARD </td><td class="markdownTableBodyNone">The phase is reversed, starting at the highest value and resetting at 1.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MVT_BACKFORTH </td><td class="markdownTableBodyNone">The phase switches between forward and backward for alternating cycles.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">MVT_RANDOM </td><td class="markdownTableBodyNone">The phase is a random value between 1 and the highest phase (number of LEDs in the segment)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MVT_STILL </td><td class="markdownTableBodyNone">The phase never changes - always returns 1.  </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md10"></a>
Color</h3>
<p><a class="anchor" id="markdown-Color"></a></p>
<p>All effect objects (descendant of <a class="el" href="class_f_f_x_base.html">FFXBase</a>) have a <a class="el" href="class_f_f_x_color.html">FFXColor</a> object that may be accessed by calling <code>getFXColor()</code>. This can be used to modify the way the color behaves any time after the initial construction. The <a class="el" href="class_f_f_x_color.html">FFXColor</a> object returned has methods to change and inspect the current color. The <code>getCRGB()</code> method returns the current CRGB value for a given pixel based on the settings and the <em>mode</em> specified for the <a class="el" href="class_f_f_x_color.html">FFXColor</a> object. Mode may be set to the following values:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Mode </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">singleCRGB </td><td class="markdownTableBodyNone">getCRGB() always returns the last value set using setCRGB() method.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">singleCHSV </td><td class="markdownTableBodyNone">getCHSV() always returns the last value set using setCHSV().  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">palette16 </td><td class="markdownTableBodyNone">Returns colors from a 16 (or fewer) entry palette set with setPalette().  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">palette256 </td><td class="markdownTableBodyNone">Returns colors from a 256 entry gradient palette. See discussion below on the nuances between the 2 palette-based color modes.  </td></tr>
</table>
<p>The palette-based color modes work in similar ways and are used to automatically step through colors in palettes using additional methods (step, shift) as follows:</p>
<ul>
<li>step() - steps forward 1 entry in the palette. Each time step() is called, the next entry will be returned by getCRGB(). Once the last entry is returned, the next call to step() starts over at the first entry. In palette16 mode, this steps forward 16 "gradient" steps to the next entryt. The setRange() method can be used to set the number of colors this will step through. So, calling setRange(4) will result in cycling through the first four colors in the palette repeatedly. In palette256 mode, step increments to the next value (including the gradients between entries).</li>
<li>shift() - This shifts the pallete forward 1 place (out of 256 total). In either palette mode, this rotates the palette forward so that when step equals 1, it will return the color in position 2 of the palette. <br  />
</li>
</ul>
<p>There is no requirement for Effects to use this object at all - colors may also be hard-coded, or customized in any other way in each effect's <code>writeNextFrame()</code> method. <br  />
</p>
<p>Refer to the pre-built effects in FFXCoreEffects for examples of how the palette color modes work.</p>
<p>Changing the color for our FirstLight effect can be done right after we initialize and add the effect to the <a class="el" href="class_f_f_x_controller.html">FFXController</a>:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">fxctrlr.getPrimarySegment()-&gt;getFX()-&gt;getFXColor().setCRGB( CRGB::Red );</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md11"></a>
FirstLight 2</h2>
<p><a class="anchor" id="markdown-FirstLight%202"></a></p>
<p>Now that we've built an effect, we can set that effect on any segment that we've defined on our <a class="el" href="class_f_f_x_controller.html">FFXController</a>. So far, we've only used the default Primary segment. In the next example, we will create 3 secondary segments on our controller and have a variation of our effect running on each segment (including the Primary segment). This only requires modificaitons to our initialization block in the setup() function:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">void setup() {</div>
<div class="line"> </div>
<div class="line">    pinMode( 5, OUTPUT );</div>
<div class="line">    FastLED.addLeds&lt;WS2811, DATA_PIN, GRB&gt;(leds, NUM_LEDS);</div>
<div class="line">    FastLED.clear();</div>
<div class="line"> </div>
<div class="line">    fxctrlr.initialize( new FFXFastLEDPixelController( leds, NUM_LEDS ) );</div>
<div class="line">    fxctrlr.getPrimarySegment()-&gt;setFX( new FirstLightFX( NUM_LEDS ) );</div>
<div class="line">    fxctrlr.getPrimarySegment()-&gt;setBrightness( 100 );</div>
<div class="line">    fxctrlr.getPrimarySegment()-&gt;getFX()-&gt;setMovement( FFXBase::MovementType::MVT_BACKFORTH );</div>
<div class="line">    FFXSegment *seg;</div>
<div class="line">    seg = fxctrlr.addSegment( &quot;Left&quot;, 0, 32 );</div>
<div class="line">    seg-&gt;setFX( new FirstLightFX( seg-&gt;getLength() ) );</div>
<div class="line">    seg-&gt;getFX()-&gt;getFXColor().setCRGB( CRGB::Red );</div>
<div class="line">    seg-&gt;getFX()-&gt;setMovement( FFXBase::MovementType::MVT_FORWARD );</div>
<div class="line">    seg-&gt;setOpacity(128);</div>
<div class="line">    </div>
<div class="line">    seg = fxctrlr.addSegment( &quot;Center&quot;, 33, 66 );</div>
<div class="line">    seg-&gt;setFX( new FirstLightFX( seg-&gt;getLength() ) );</div>
<div class="line">    seg-&gt;getFX()-&gt;getFXColor().setCRGB( CRGB::Blue );</div>
<div class="line">    seg-&gt;getFX()-&gt;setMovement( FFXBase::MovementType::MVT_BACKFORTH );</div>
<div class="line">    seg-&gt;setOpacity(128);</div>
<div class="line">    </div>
<div class="line">    seg = fxctrlr.addSegment( &quot;Right&quot;, 67, 99 );</div>
<div class="line">    seg-&gt;setFX( new FirstLightFX( seg-&gt;getLength() ) );</div>
<div class="line">    seg-&gt;getFX()-&gt;getFXColor().setCRGB( CRGB::Green );</div>
<div class="line">    seg-&gt;getFX()-&gt;setMovement( FFXBase::MovementType::MVT_BACKWARD );</div>
<div class="line">    seg-&gt;setOpacity(128);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now we have 4 versions of this effect running:</p><ol type="1">
<li>Running on the primary segment, color is white and moving back and forth</li>
<li>Running on the segment named "Left", color is red, moving forward only at opacity of 128 (about 50%) so the underlying primary effect will still show below it.</li>
<li>Running on the segment named "Center", color is green, moving back and forth at opacity of 128.</li>
<li>Running on the segment named "Right", color is blue, moving backward at opacity of 128.</li>
</ol>
<h3><a class="anchor" id="autotoc_md12"></a>
Segments</h3>
<p><a class="anchor" id="markdown-Segments"></a></p>
<p>The above code illustrates how to create segments using <code>addSegment()</code> Each segment is given a <em>Name</em> (or <em>Tag</em>). This name is used to reference the segment any time after it has been added. A pointer to the segment is returned by the <code>AddSegment()</code> method, but may also be obtained later using the <code>FFXController.findSegment(String name)</code> method. Once the segment has been created, the following methods may be used to control how it is shown:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Segment Method </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">setFX(FFXBase*) </td><td class="markdownTableBodyNone">Set the active effect running on the segment  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">getFX() </td><td class="markdownTableBodyNone">Return a pointer to the active effect on the segment  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">setBrightness(uint8_t) </td><td class="markdownTableBodyNone">By default, a segments brightness is "inherited" from the primary segment. Calling <code>setBrightness()</code> will override that behavior and make the brightness independent. The brightness will remain at this level, regardless of any changes made to the primary segment's brightness.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">hasDimmer() </td><td class="markdownTableBodyNone">Returns true if the segment's brighness is independent (i.e. not linked to the primary segment.)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">removeDimmer() </td><td class="markdownTableBodyNone">Removes the independent dimmer and links brightness back to the brightness of the primary segment.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">setOpacity( uint8_t ) </td><td class="markdownTableBodyNone">Sets the opacity of the segment. SetOpacity(0) makes the segment completely invisible, setOpacity(255) makes it completely opaque.  </td></tr>
</table>
<p>Changes to brightness and opacity, both utilize <em>auto-fader</em> settings. This means that changes to their values aren't applied all at once. They gradually <em>fade</em> to the next setting to make the changes less jarring. By default, the changes to brighness are faded over 500 milliseconds and changes to opacity are faded over 750 milliseconds. Either of these times can be changed by calling <code>setBrightnessInverval(unsigned long)</code> or <code>setOpacityInterval(unsigned long)</code>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
