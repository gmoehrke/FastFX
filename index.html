<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FastFX: FFX - FastFX library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="FFX.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FastFX
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">LED Strip Animation and Effects Framework for Arduino</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">FFX - FastFX library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="markdown-FFX%20-%20FastFX%20library"></a></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Table of Contents</h1>
<p><a class="anchor" id="markdown-Table%20of%20Contents"></a></p>
<ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#intro">Intro</a></li>
<li><a href="#overview">Overview</a><ul>
<li><a href="#dependency">Dependency</a></li>
</ul>
</li>
<li><a href="#model">Model</a></li>
<li><a href="#tutorial--examples">Tutorial &amp; Examples</a><ul>
<li><a href="#firstlight">FirstLight</a><ul>
<li><a href="#cycle-and-phase">Cycle and Phase</a></li>
<li><a href="#initialization">Initialization</a></li>
<li><a href="#speed-and-cross-fade">Speed and Cross-fade</a></li>
</ul>
</li>
<li><a href="#firstlight-2">FirstLight 2</a><ul>
<li><a href="#movementtype">MovementType</a></li>
<li><a href="#color">Color</a></li>
<li><a href="#namedpalettes">NamedPalettes</a></li>
</ul>
</li>
<li><a href="#firstlight-3">FirstLight 3</a><ul>
<li><a href="#segments">Segments</a></li>
<li><a href="#overlay-effects">Overlay Effects</a></li>
<li><a href="#timers">Timers</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Intro</h1>
<p><a class="anchor" id="markdown-Intro"></a></p>
<p>Thanks for checking out FFX. This project grew out my desire to have a single code-base for several different LED Strips I have installed in various locations around my home. My goal was to have a single firmware image that could be downloaded on every controller, yet have the ability to change the colors/effects/etc. independently. That goal has been realized in a forthcoming framework that utilizes MQTT, JSON and a message based system for configuration and control of individual nodes (LED Controllers, sensors, relays, etc). The FFX library is the foundation for the LED controller used in that architecture.</p>
<p>The examples in the following sections illustrate the basics, but don't touch on everything. All of the coding and development was done on NodeMCU ESP8266 boards. While I haven't tested on anything else, outside of the FastLED initialization and pin selection, it doesn't do anything that is processor dependent, so it should run just as well on other platforms. <br  />
</p>
<p>Final Note - The examples included in the framework are optimized for WS2811 strips (12v 3-LEDs per pixel). Some of the default parameters may need to be tweaked slightly to look best on other strip configurations.</p>
<p>Complete Documentation is available here: <a href="https://gmoehrke.github.io/FastFX">https://gmoehrke.github.io/FastFX</a></p>
<h1><a class="anchor" id="autotoc_md3"></a>
Overview</h1>
<p><a class="anchor" id="markdown-Overview"></a></p>
<p>FFX is an Arduino library that for creating LED Strip effects and animations. The principle idea behind the library is to provide a set of reusable classes/objects to create and display multiple colors/animations/etc. consistently in any sketch. Effects are written as classes/subclasses and displayed by a common controller object. By defining effects as objects, FFX is able to provide capabilities that are common to all effects without the need to custom code them for each individual effect. These capabilities include:</p>
<ul>
<li>Automatic crossfade between "frames" - useful for smoother transitions in slower moving sequences.</li>
<li>Automatic crossfade between effects - gradual fade between effects when changing from one effect to another</li>
<li>Segments - Multiple effects shown in different segments of the same Strip</li>
<li>Transparency - One effect shown over the top of another with variable transparency (while both continue to animate)</li>
<li>Common Color/Palette Management - Color object/interface to change the look of effects without custom coding each color/combination</li>
<li>Independent timing - Each effect maintains its own independent Timer</li>
<li>Overlay Sequences - Brief animation sequences that can be show over the top of looping effects (with variable transparency). Useful for indicating events, transitions, etc. <br  />
</li>
<li>Auto-faders for dimming and transparency - allows for smooth transitions when changing brightness and/or transparency levels. Timing can be set independently for each. <br  />
</li>
</ul>
<h2><a class="anchor" id="autotoc_md4"></a>
Dependency</h2>
<p><a class="anchor" id="markdown-Dependency"></a></p>
<p>The FastFX library requires the FastLED library: <a href="https://github.com/FastLED/FastLED">https://github.com/FastLED/FastLED</a>. Users attempting to use this library should have a basic understanding of FastLED and have the library installed and working (version 3.3 or greater).</p>
<p>The library also makes use of 2 timer classes (<a class="el" href="class_step_timer.html">StepTimer</a>, <a class="el" href="class_flex_timer.html">FlexTimer</a>). These are included in the repository, but may be released as a separate library at some time in the future.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Model</h1>
<p><a class="anchor" id="markdown-Model"></a></p>
<p>The programming model for using FastFX differs slightly from coding directly with FastLED. The following is a brief description of the classes needed to create a sketch using FastFX:</p>
<p><img src="images/FFX_Classes.jpg" alt="classes" class="inline"/></p>
<ul>
<li><b><a class="el" href="class_f_f_x_base.html">FFXBase</a></b> - Each effect is written as a subclass of the <a class="el" href="class_f_f_x_base.html">FFXBase</a> class. <a class="el" href="class_f_f_x_base.html">FFXBase</a> has its own timing parameters that determine how many milliseconds each "frame" will last. The smaller the interval, the faster the animation. <a class="el" href="class_f_f_x_base.html">FFXBase</a> provides two virtual methods that may be overridden. The most important is the WriteNextFrame() method. This method is used to make changes to a FastLED CRGB array (*CRGB[]) that represents the pixels to draw. The FastFX framework includes several pre-built effect classes, including the default <a class="el" href="class_solid_f_x.html">SolidFX</a> class, which represents a single static color (see FXXCoreEffects.h)</li>
<li><p class="startli"><b><a class="el" href="class_f_f_x_segment.html">FFXSegment</a></b> - A single LED strip is represented by a set of one or more segments. Each strip contains a <em>Primary</em> segment, which represents the entire strip. If effects will only be displayed along the entire strip, this is the only segment that needs to be present. If multiple effects are desired, then additional <em>secondary</em> segments may be defined. These segments may each have a different effect and each has its own <em>opacity</em> setting (0-255, 0=100% transparent, 255=100% opaque). The secondary segments do not need to cover the entire length of the primary segment. Pixels in the primary segment will always be visible unless they are covered by a secondary segment (and the secondary segment's opacity is greater than 0).</p>
<p class="startli">Each secondary segment is given a name or <em>Tag</em>, which is used to reference that segment on the controller. The controller provides 2 methods to access the individual segments - getPrimarySegment() and findSegment(String tag), each returns a pointer to the appropriate segment. Note that these pointers can be dereferenced safely without checking for NULLs, if an invalid segment name is specified for findSegment, a pointer to the primary segment will be returned. <br  />
</p>
<p class="startli"><img src="images/Segments.jpg" alt="segments" class="inline"/></p>
<p class="startli">Each segment maintains a <a class="el" href="class_f_f_x_frame_provider.html">FFXFrameProvider</a> object that is responsible for returning the frames to be drawn for each update. The frame provider manages the cross fading, allocating extra buffers when needed.</p>
</li>
<li><b><a class="el" href="class_f_f_x_controller.html">FFXController</a></b> - This is the main interface for the FastFX framework. Every FastFX sketch will create an <a class="el" href="class_f_f_x_controller.html">FFXController</a> object and then use that object to define segments, start/stop effects and set various other parameters (brightness, opacity, speed, etc).</li>
</ul>
<h1><a class="anchor" id="autotoc_md6"></a>
Tutorial &amp; Examples</h1>
<p><a class="anchor" id="markdown-Tutorial%20%26%20Examples"></a></p>
<h2><a class="anchor" id="autotoc_md7"></a>
FirstLight</h2>
<p><a class="anchor" id="markdown-FirstLight"></a></p>
<p>Since each effect is a standalone class, creating a new one is a straightforward task. Taking from the "FirstLight" example code in the FastLED library, we will create a FastFX version and see how we gain additional functionality with FastFX. First we'll construct the effect class, which is always a descendant of <a class="el" href="class_f_f_x_base.html">FFXBase</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>FirstLightFX : <span class="keyword">public</span> <a class="code" href="class_f_f_x_base.html">FFXBase</a> {</div>
<div class="line">  <span class="keyword">public</span>:    </div>
<div class="line">    <span class="comment">// Constructor - provides defaults for interval, minInterval, and maxInterval</span></div>
<div class="line">    FirstLightFX(uint16_t initSize) : <a class="code" href="class_f_f_x_base.html">FFXBase</a>( initSize, 10UL, 10UL, 100UL ) {</div>
<div class="line">      <span class="comment">// currColor holds the FFXColor object used to manage colors in effects - this is a</span></div>
<div class="line">      <span class="comment">// simple single-color effect using RGB colors, so we set the mode to singleCRGB</span></div>
<div class="line">      currColor.setColorMode( FFXColor::FXColorMode::singleCRGB );</div>
<div class="line">      <span class="comment">// then supply it the color</span></div>
<div class="line">      currColor.setCRGB( CRGB::White );</div>
<div class="line">      <span class="comment">// effect is running on a segment of the strip.</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Override initLeds - this method is called only once, right before the first frame is drawn</span></div>
<div class="line">    <span class="comment">// Note that anything done here is not &quot;shown&quot; until after the first call to writeNextFrame()</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_f_f_x_base.html#a9b87b093056a46882e3649f6d79ff737">initLeds</a>( CRGB *bufLeds )<span class="keyword"> override </span>{</div>
<div class="line">      <span class="comment">// Clear the field</span></div>
<div class="line">      fill_solid( bufLeds, <a class="code" href="class_f_f_x_base.html#ae927731c7144999d13db35a1edfbea51">getNumLeds</a>(), CRGB::Black );</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Override writeNextFrame - this is what is called for each change.  Note that the controller</span></div>
<div class="line">    <span class="comment">// will only call this once for each frame, so we don&#39;t need to track anything about the Timing</span></div>
<div class="line">    <span class="comment">// or coordination with other effects...just write the frame data into the passed CRGB array</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_f_f_x_base.html#aa9e3d2fba5e2629ba4651760e3c48745">writeNextFrame</a>( CRGB *bufLeds )<span class="keyword"> override </span>{</div>
<div class="line">      <span class="comment">// fade any lit pixels to leave a trail behind the moving colored pixel</span></div>
<div class="line">      fadeToBlackBy( bufLeds, numLeds, 50 );</div>
<div class="line">      <span class="comment">// set the next pixel to the current value in our FFXColor object (white, in this case)</span></div>
<div class="line">      bufLeds[<a class="code" href="class_f_f_x_base.html#accea39ca5bb87b6d6104ca362e930e0a">getCurrPhase</a>()-1] = currColor.getCRGB();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md8"></a>
Cycle and Phase</h3>
<p><a class="anchor" id="markdown-Cycle%20and%20Phase"></a></p>
<p>Note the use of <code>getCurrPhase()</code> here. All effects have running counters for <em>Phase</em> and <em>Cycle</em>. The Phase counter starts at 1, and increments for each step until it reaches the number of pixels covered by that effect. This is considered one cycle. Once a cycle is completed, the phase is reset to 1. The <code>getCurrCycle()</code> method returns the count of how many times this has been repeated. For an effect running at an interval of 10 (milliseconds) with 100 pixels, a single phase will take 10 milliseconds, while a full cycle will take 1 second (1000 milliseconds). <br  />
</p>
<p><a class="el" href="class_f_f_x_base.html">FFXBase</a> also includes capabilities to specify virtual cycle and phase settings which can differ from the length of the segment (using setVCycleRange, getCurrVCycle &amp; getCurrVPhase). <br  />
</p>
<p>Note that the use of Phase and Cycle in implementing effects is not mandatory. An effect can completely ignore them and still be 100% functional. They simply provide some convenient reference points and can be very useful for calculating motion and timing when used appropriately.</p>
<h3><a class="anchor" id="autotoc_md9"></a>
Initialization</h3>
<p><a class="anchor" id="markdown-Initialization"></a></p>
<p>For FastLED, we need the CRGB array that represents the pixels in our strip, and we will also need a <a class="el" href="class_f_f_x_controller.html">FFXController</a> object for FastFX. So, the following 2 globals are defined:</p>
<div class="fragment"><div class="line">CRGB leds[NUM_LEDS]</div>
<div class="line"><a class="code" href="class_f_f_x_controller.html">FFXController</a> fxctrlr = <a class="code" href="class_f_f_x_controller.html">FFXController</a>();</div>
</div><!-- fragment --><p>Now we can modify the setup() function to create and initialize an instance of the <a class="el" href="class_f_f_x_controller.html">FFXController</a>, and create and add the effect to the controller:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup() {</div>
<div class="line">    pinMode( 5, OUTPUT );</div>
<div class="line">    FastLED.addLeds&lt;WS2811, DATA_PIN, GRB&gt;(leds, NUM_LEDS);</div>
<div class="line">    FastLED.clear();</div>
<div class="line"> </div>
<div class="line">    fxctrlr.initialize( <span class="keyword">new</span> <a class="code" href="class_f_f_x_fast_l_e_d_pixel_controller.html">FFXFastLEDPixelController</a>( leds, NUM_LEDS ) );</div>
<div class="line">    fxctrlr.getPrimarySegment()-&gt;setFX( <span class="keyword">new</span> FirstLightFX( NUM_LEDS ) );</div>
<div class="line">    fxctrlr.getPrimarySegment()-&gt;setBrightness( 100 );</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now that we've built all of the instructions for creating the effect into our FirstLightFX class and added it to the controller, the main loop simply needs to make sure the controller continues to run:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> loop() {</div>
<div class="line">  fxctrlr.update();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The full code can be found in <a href="examples/FirstLight_1/FirstLight_1.ino">examples/FirstLight_1/FirstLight_1.ino</a>. <br  />
</p>
<h3><a class="anchor" id="autotoc_md10"></a>
Speed and Cross-fade</h3>
<p><a class="anchor" id="markdown-Speed%20and%20Cross-fade"></a></p>
<p>When running this example, note that you may select a different interval value to control the speed of the animation. Thas may be done by calling: </p><div class="fragment"><div class="line">fxctrlr.getPrimarySegment()-&gt;getFX().setInterval( newInterval );</div>
</div><!-- fragment --><p>The interval may be changed any time after creating the effect. By using a larger interval (200+ milliseconds), you may notice that the leading white dot fades in over the duration of that interval to make the animation smoother. This is because crossfading is enabled by default by the framework. The extra buffers and frame-blending are all done automatically. This can be disabled on any individual effect by calling </p><div class="fragment"><div class="line">fxctrlr.getPrimarySegment()-&gt;getFrameProvider()-&gt;setCrossFade(<span class="keyword">false</span>)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md11"></a>
FirstLight 2</h2>
<p><a class="anchor" id="markdown-FirstLight%202"></a></p>
<h3><a class="anchor" id="autotoc_md12"></a>
MovementType</h3>
<p><a class="anchor" id="markdown-MovementType"></a></p>
<p>In the above example, the movement is uni-directional - in only goes from low to high and starts over. All FastFX effect have a MovementType setting, which can be set using <code>setMovement( MovementType )</code> and inspected using <code>getMovement()</code>. This may be used to support more flexible patterns of motion without having to code each individually. The Phase of the effect can be inspected normally through <code>getCurrPhase()</code>, but it may also be interpreted through <code>getMovementPhase()</code>, which will interpret the Phase in respect to the MovementType setting on the effect as follows:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">MovementType </th><th class="markdownTableHeadNone">MovementPhase  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MVT_FORWARD </td><td class="markdownTableBodyNone">The phase increments normally and resets to 1 at the end of each cycle.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">MVT_BACKWARD </td><td class="markdownTableBodyNone">The phase is reversed, starting at the highest value and resetting at 1.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MVT_BACKFORTH </td><td class="markdownTableBodyNone">The phase switches between forward and backward for alternating cycles.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">MVT_RANDOM </td><td class="markdownTableBodyNone">The phase is a random value between 1 and the highest phase (number of LEDs in the segment)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MVT_STILL </td><td class="markdownTableBodyNone">The phase never changes - always returns 1.  </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md13"></a>
Color</h3>
<p><a class="anchor" id="markdown-Color"></a></p>
<p>All effect objects (descendant of <a class="el" href="class_f_f_x_base.html">FFXBase</a>) have a <a class="el" href="class_f_f_x_color.html">FFXColor</a> object that may be accessed by calling <code>getFXColor()</code>. This can be used to modify the way the color behaves any time after the initial construction. The <a class="el" href="class_f_f_x_color.html">FFXColor</a> object returned has methods to change and inspect the current color. The <code>getCRGB()</code> method returns the current CRGB value for a given pixel based on the settings and the <em>mode</em> specified for the <a class="el" href="class_f_f_x_color.html">FFXColor</a> object. Mode may be set to the following values:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Mode </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">singleCRGB </td><td class="markdownTableBodyNone">getCRGB() always returns the last value set using setCRGB() method.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">singleCHSV </td><td class="markdownTableBodyNone">getCHSV() always returns the last value set using setCHSV().  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">palette16 </td><td class="markdownTableBodyNone">Returns colors from a 16 (or fewer) entry palette set with setPalette(). Useful for effects that use a limited number of colors.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">palette256 </td><td class="markdownTableBodyNone">Returns colors from a 256 entry gradient palette. See discussion below on the nuances between the 2 palette-based color modes.  </td></tr>
</table>
<p>The palette-based color modes work in similar ways and are used to automatically step through colors in palettes using additional methods (step, shift) as follows:</p>
<ul>
<li>step() - steps forward 1 entry in the palette. Each time step() is called, the next entry will be returned by getCRGB(). Once the last entry is returned, the next call to step() starts over at the first entry. In palette16 mode, this steps forward to the next entry. The setRange() method can be used to set the number of colors this will step through. So, calling setRange(4) will result in cycling through the first four colors in the palette repeatedly. In palette256 mode, step increments to the next value (among all 256 entries).</li>
<li>shift() - This shifts the pallete forward 1 place (out of 256 total). Shift is useful if an effect needs to fill an array using step(). Then shift() may be used to shift the palette forward 1 place before the next cycle. Only applies to palette256 mode, this is not particularly useful in palette16 mode.</li>
</ul>
<p><a class="el" href="class_f_f_x_color.html">FFXColor</a> may also be used as just a means to store a palette used by the effect by using only <code>setPalette()</code> and <code>getPalette*()</code></p>
<p>There is no requirement for Effects to use this object at all - colors may also be hard-coded, or customized in any other way in each effect's <code>writeNextFrame()</code> method. <br  />
</p>
<p>A small change to the <code>writeNextFrame()</code> method will allow us to support the palette color modes as follows: if the mode is palette16, the effect will step to the next color at either end of the strip (or segment) on which it is running. In palette256 mode, the effect will simply step through entire palette as it moves.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> writeNextFrame( CRGB *bufLeds )<span class="keyword"> override </span>{</div>
<div class="line">  fadeToBlackBy( bufLeds, numLeds, 50 );</div>
<div class="line">  bufLeds[getMovementPhase()-1] = currColor.getCRGB();</div>
<div class="line">  <span class="keywordflow">switch</span> (currColor.getColorMode()) {</div>
<div class="line">    <span class="comment">// Blend the moving pixel through the entire palette range</span></div>
<div class="line">    <span class="keywordflow">case</span> FFXColor::FFXColorMode::palette256 : {</div>
<div class="line">      currColor.step();</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Step through the active colors in the palette - switching at either end of the strip</span></div>
<div class="line">    <span class="keywordflow">case</span> FFXColor::FFXColorMode::palette16 : {</div>
<div class="line">      <span class="keywordflow">if</span> (getCurrPhase()==0 || getCurrPhase()==numLeds) {</div>
<div class="line">         currColor.step();</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">default</span>:  { }</div>
<div class="line">    }</div>
<div class="line">  }</div>
</div><!-- fragment --><p>The full code can be found in <a href="examples/FirstLight_2/FirstLight_2.ino">examples/FirstLight_2/FirstLight_2.ino</a>. <br  />
 Changing the color for our FirstLight effect can be done right after we initialize and add the effect to the <a class="el" href="class_f_f_x_controller.html">FFXController</a>:</p>
<p>singleCRGB:</p>
<div class="fragment"><div class="line"><a class="code" href="class_f_f_x_color.html">FFXColor</a> &amp;clr = fxctrlr.getPrimarySegment()-&gt;getFX()-&gt;getFXColor();</div>
<div class="line">clr.<a class="code" href="class_f_f_x_color.html#ae6fd5d166fcda81c18a926d0e66fcac1">setCRGB</a>( CRGB::Red );</div>
</div><!-- fragment --><p>palette256:</p>
<div class="fragment"><div class="line"><a class="code" href="class_f_f_x_color.html">FFXColor</a> &amp;clr = fxctrlr.getPrimarySegment()-&gt;getFX()-&gt;getFXColor();</div>
<div class="line">clr.<a class="code" href="class_f_f_x_color.html#a202ed99e460037832487067a51cf9037">setColorMode</a>( FFXColor::FFXColorMode::palette256 );</div>
<div class="line">clr.<a class="code" href="class_f_f_x_color.html#a28c390eabee5bc96769605777781828f">setPalette</a>( <a class="code" href="class_named_palettes.html#a1aa700b9935d0de65fa9784322358edb">NamedPalettes::getInstance</a>()[<span class="stringliteral">&quot;party&quot;</span>] );</div>
</div><!-- fragment --><p>palette16:</p>
<div class="fragment"><div class="line"><a class="code" href="class_f_f_x_color.html">FFXColor</a> &amp;clr = fxctrlr.getPrimarySegment()-&gt;getFX()-&gt;getFXColor();</div>
<div class="line">clr.<a class="code" href="class_f_f_x_color.html#a202ed99e460037832487067a51cf9037">setColorMode</a>( FFXColor::FFXColorMode::palette16 );</div>
<div class="line">clr.<a class="code" href="class_f_f_x_color.html#a28c390eabee5bc96769605777781828f">setPalette</a>( <a class="code" href="class_named_palettes.html#a1aa700b9935d0de65fa9784322358edb">NamedPalettes::getInstance</a>()[<span class="stringliteral">&quot;multi&quot;</span>] );</div>
<div class="line">clr.<a class="code" href="class_f_f_x_color.html#a5a07e8ae125d13e0f3206ac62d84e509">setPaletteRange</a>( 6 );</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md14"></a>
NamedPalettes</h3>
<p><a class="anchor" id="markdown-NamedPalettes"></a></p>
<p>Note in the above palette examples, the use of a singleton object "NamedPalettes". This is a class defined in FFXCoreEffects and may be used to reference global palettes using a String rather than hard-coding them. By default, most of the global FastLED palettes are present and available for use. They are obtained using <code><a class="el" href="class_named_palettes.html#a1aa700b9935d0de65fa9784322358edb">NamedPalettes::getInstance()</a>[ String paletteName ]</code>. <br  />
</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Index Name </th><th class="markdownTableHeadNone">Palette  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">multi </td><td class="markdownTableBodyNone">Multi_p  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">red </td><td class="markdownTableBodyNone">red_wave_gp  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">yellow </td><td class="markdownTableBodyNone">yellow_wave_gp  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">blue </td><td class="markdownTableBodyNone">blue_wave_gp  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">green </td><td class="markdownTableBodyNone">green_wave_gp  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">orange </td><td class="markdownTableBodyNone">orange_wave_gp  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">softwhite_scale </td><td class="markdownTableBodyNone">soft_white_dim_gp  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ocean </td><td class="markdownTableBodyNone">OceanColors_p  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cloud </td><td class="markdownTableBodyNone">CloudColors_p  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">forest </td><td class="markdownTableBodyNone">ForestColors_p  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">lava </td><td class="markdownTableBodyNone">LavaColors_p  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">heat </td><td class="markdownTableBodyNone">HeatColors_p  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">party </td><td class="markdownTableBodyNone">PartyColors_p  </td></tr>
</table>
<p>To add a named palette to the global object, use the following:</p>
<div class="fragment"><div class="line"><a class="code" href="class_named_palettes.html">NamedPalettes</a>.<a class="code" href="class_named_palettes.html#a1aa700b9935d0de65fa9784322358edb">getInstance</a>().<a class="code" href="class_named_palettes.html#a85d0dc0568c78c47a3de142208df9c2c">addNamedPalette</a>( <span class="stringliteral">&quot;myPalette&quot;</span>, myPalette_p );</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md15"></a>
FirstLight 3</h2>
<p><a class="anchor" id="markdown-FirstLight%203"></a></p>
<p>Now that we've built an effect, we can set that effect on any segment that we've defined on our <a class="el" href="class_f_f_x_controller.html">FFXController</a>. So far, we've only used the default Primary segment. In the next example, we will create 3 secondary segments on our controller and have a variation of our effect running on each segment (including the Primary segment). This only requires modificaitons to our initialization block in the setup() function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup() {</div>
<div class="line"> </div>
<div class="line">    pinMode( 5, OUTPUT );</div>
<div class="line">    FastLED.addLeds&lt;WS2811, DATA_PIN, GRB&gt;(leds, NUM_LEDS);</div>
<div class="line">    FastLED.clear();</div>
<div class="line"> </div>
<div class="line">    fxctrlr.initialize( <span class="keyword">new</span> <a class="code" href="class_f_f_x_fast_l_e_d_pixel_controller.html">FFXFastLEDPixelController</a>( leds, NUM_LEDS ) );</div>
<div class="line">    fxctrlr.getPrimarySegment()-&gt;setFX( <span class="keyword">new</span> FirstLightFX( NUM_LEDS ) );</div>
<div class="line">    fxctrlr.getPrimarySegment()-&gt;setBrightness( 100 );</div>
<div class="line">    fxctrlr.getPrimarySegment()-&gt;getFX()-&gt;setMovement( FXBase::MovementType::MVT_BACKFORTH );</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="class_f_f_x_segment.html">FFXSegment</a> *seg;</div>
<div class="line">    seg = fxctrlr.addSegment( <span class="stringliteral">&quot;Left&quot;</span>, 0, 32 );</div>
<div class="line">    seg-&gt;<a class="code" href="class_f_f_x_segment.html#a6b19e4eec3bc1fdd53c6470c8a56af51">setFX</a>( <span class="keyword">new</span> FirstLightFX( seg-&gt;<a class="code" href="class_f_f_x_segment.html#abe7780410001dae96a874259b876f793">getLength</a>() ) );</div>
<div class="line">    seg-&gt;<a class="code" href="class_f_f_x_segment.html#ac77439a83bf7267aea333382c0c1d092">getFX</a>()-&gt;<a class="code" href="class_f_f_x_base.html#a460d35bfdba1b665ce9a54d7673cb2ca">getFXColor</a>().<a class="code" href="class_f_f_x_color.html#ae6fd5d166fcda81c18a926d0e66fcac1">setCRGB</a>( CRGB::Red );</div>
<div class="line">    seg-&gt;<a class="code" href="class_f_f_x_segment.html#ac77439a83bf7267aea333382c0c1d092">getFX</a>()-&gt;<a class="code" href="class_f_f_x_base.html#a46da8a20feea1e3731b9f28752ed8cc9">setMovement</a>( FFXBase::MovementType::MVT_FORWARD );</div>
<div class="line">    seg-&gt;<a class="code" href="class_f_f_x_segment.html#afaed139def1a7c05301825ad39b22e23">setOpacity</a>(128|</div>
<div class="line"> </div>
<div class="line">    seg = fxctrlr.addSegment( <span class="stringliteral">&quot;Center&quot;</span>, 33, 66 );</div>
<div class="line">    seg-&gt;<a class="code" href="class_f_f_x_segment.html#a6b19e4eec3bc1fdd53c6470c8a56af51">setFX</a>( <span class="keyword">new</span> FirstLightFX( seg-&gt;<a class="code" href="class_f_f_x_segment.html#abe7780410001dae96a874259b876f793">getLength</a>() ) );</div>
<div class="line">    seg-&gt;<a class="code" href="class_f_f_x_segment.html#ac77439a83bf7267aea333382c0c1d092">getFX</a>()-&gt;<a class="code" href="class_f_f_x_base.html#a460d35bfdba1b665ce9a54d7673cb2ca">getFXColor</a>().<a class="code" href="class_f_f_x_color.html#ae6fd5d166fcda81c18a926d0e66fcac1">setCRGB</a>( CRGB::Blue );</div>
<div class="line">    seg-&gt;<a class="code" href="class_f_f_x_segment.html#ac77439a83bf7267aea333382c0c1d092">getFX</a>()-&gt;<a class="code" href="class_f_f_x_base.html#a46da8a20feea1e3731b9f28752ed8cc9">setMovement</a>( FFXBase::MovementType::MVT_BACKFORTH );</div>
<div class="line">    seg-&gt;<a class="code" href="class_f_f_x_segment.html#afaed139def1a7c05301825ad39b22e23">setOpacity</a>(128);</div>
<div class="line"> </div>
<div class="line">    seg = fxctrlr.addSegment( <span class="stringliteral">&quot;Right&quot;</span>, 67, 99 );</div>
<div class="line">    seg-&gt;<a class="code" href="class_f_f_x_segment.html#a6b19e4eec3bc1fdd53c6470c8a56af51">setFX</a>( <span class="keyword">new</span> FirstLightFX( seg-&gt;<a class="code" href="class_f_f_x_segment.html#abe7780410001dae96a874259b876f793">getLength</a>() ) );</div>
<div class="line">    seg-&gt;<a class="code" href="class_f_f_x_segment.html#ac77439a83bf7267aea333382c0c1d092">getFX</a>()-&gt;<a class="code" href="class_f_f_x_base.html#a460d35bfdba1b665ce9a54d7673cb2ca">getFXColor</a>().<a class="code" href="class_f_f_x_color.html#ae6fd5d166fcda81c18a926d0e66fcac1">setCRGB</a>( CRGB::Green );</div>
<div class="line">    seg-&gt;<a class="code" href="class_f_f_x_segment.html#ac77439a83bf7267aea333382c0c1d092">getFX</a>()-&gt;<a class="code" href="class_f_f_x_base.html#a46da8a20feea1e3731b9f28752ed8cc9">setMovement</a>( FFXBase::MovementType::MVT_BACKWARD );</div>
<div class="line">    seg-&gt;<a class="code" href="class_f_f_x_segment.html#afaed139def1a7c05301825ad39b22e23">setOpacity</a>(128);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now we have 4 versions of this effect running:</p><ol type="1">
<li>Running on the primary segment, color is white and moving back and forth</li>
<li>Running on the segment named "Left", color is red, moving forward only at opacity of 128 (about 50%) so the underlying primary effect will still show below it.</li>
<li>Running on the segment named "Center", color is green, moving back and forth at opacity of 128.</li>
<li>Running on the segment named "Right", color is blue, moving backward at opacity of 128.</li>
</ol>
<p>Note that the main loop remains unchanged - just one line of code:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> loop() {</div>
<div class="line">  fxctrlr.update();</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md16"></a>
Segments</h3>
<p><a class="anchor" id="markdown-Segments"></a></p>
<p>The above code illustrates how to create segments using <code>addSegment()</code> Each segment is given a <em>Name</em> (or <em>Tag</em>). This name is used to reference the segment any time after it has been added. A pointer to the segment is returned by the <code>AddSegment()</code> method, but may also be obtained later using the <code>FFXController.findSegment(String name)</code> method. Once the segment has been created, the following methods may be used to control how it is shown:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Segment Method </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">setFX(FFXBase*) </td><td class="markdownTableBodyNone">Set the active effect running on the segment  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">getFX() </td><td class="markdownTableBodyNone">Return a pointer to the active effect on the segment  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">setBrightness(uint8_t) </td><td class="markdownTableBodyNone">By default, a segments brightness is "inherited" from the primary segment. Calling <code>setBrightness()</code> will override that behavior and make the brightness independent. The brightness will remain at this level, regardless of any changes made to the primary segment's brightness.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">hasDimmer() </td><td class="markdownTableBodyNone">Returns true if the segment's brighness is independent (i.e. not linked to the primary segment.)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">removeDimmer() </td><td class="markdownTableBodyNone">Removes the independent dimmer and links brightness back to the brightness of the primary segment.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">setOpacity( uint8_t ) </td><td class="markdownTableBodyNone">Sets the opacity of the segment. SetOpacity(0) makes the segment completely invisible, setOpacity(255) makes it completely opaque.  </td></tr>
</table>
<p>Changes to brightness and opacity, both utilize <em>auto-fader</em> settings. This means that changes to their values aren't applied all at once. They gradually <em>fade</em> to the next setting to make the changes less jarring. By default, the changes to brighness are faded over 500 milliseconds and changes to opacity are faded over 750 milliseconds. Either of these times can be changed by calling <code>setBrightnessInverval(unsigned long)</code> or <code>setOpacityInterval(unsigned long)</code>.</p>
<h3><a class="anchor" id="autotoc_md17"></a>
Overlay Effects</h3>
<p><a class="anchor" id="markdown-Overlay%20Effects"></a></p>
<p>Overlay effects are momentary sequences that can be run over existing effects. Overlay sequences are run over the top of the primary segment they are typically short sequences, which run one or more times. Depending on how they are written - then can overlay the entire strip, just a portion, or a moving section leaving the remaining animations running in the background. There are 2 example overlay effects in the <a class="el" href="_f_f_x_core_effects_8h.html">FFXCoreEffects.h</a> file <code><a class="el" href="class_pulse_overlay_f_x.html">PulseOverlayFX</a></code>, <code><a class="el" href="class_zip_overlay_f_x.html">ZipOverlayFX</a></code> and <code><a class="el" href="class_wave_overlay_f_x.html">WaveOverlayFX</a></code> (<a class="el" href="class_wave_overlay_f_x.html">WaveOverlayFX</a> is limited to strips with over 54 pixels). <br  />
</p>
<p>Adding an overlay effect is as easy as adding an effect, however overlays are added at the controller, rather than the segment. Only one overlay effect may be added at a given time. Overlay effects are automatically removed and deleted when they have completed so once they've been added, nothing more needs to be done. Here's what the addition of an overlay looks like:</p>
<div class="fragment"><div class="line"><a class="code" href="class_pulse_overlay_f_x.html">PulseOverlayFX</a> *newFX= <span class="keyword">new</span> <a class="code" href="class_pulse_overlay_f_x.html">PulseOverlayFX</a>( fxctrlr.getPrimarySegment()-&gt;getLength(), 220, 1, color );</div>
<div class="line">    newFX-&gt;<a class="code" href="class_pulse_overlay_f_x.html#ac88e59adc4713e2a910c8ed60e7aac80">setPixelRange</a>( 34, 64 );</div>
<div class="line">    fxctrlr.setOverlayFX(newFX);  </div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md18"></a>
Timers</h3>
<p><a class="anchor" id="markdown-Timers"></a></p>
<p>There are two timer classes used for various functions throughout the framework. These are a handy way to time events without having to rely on callbacks or iterrupts. I refer to these as <em>passive</em> timers, because they do not actively fire when the time has elapsed - they must be checked repeatedly to see if the time has expired, then re-armed if needed. The usage model is as follows:</p>
<ul>
<li>Create and start the timer with a default interval.</li>
<li>Inside the main loop:<ul>
<li>If timer has expired - <code>isUp()==true</code><ul>
<li>perform task(s)</li>
<li>re-arm the timer if needed - <code>timer.step()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Here is sample code:</p>
<div class="fragment"><div class="line"><a class="code" href="class_step_timer.html">StepTimer</a> timer( 1000 );</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line">timer.start();</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">  <span class="keywordflow">if</span> timer.isUp() {</div>
<div class="line">    <span class="comment">// do stuff here - realize that stuff done here is &quot;after cycle&quot; so each cycle will</span></div>
<div class="line">    <span class="comment">// use the time elapsed by the timer PLUS whatever time is taken by steps performed here.</span></div>
<div class="line">    timer.step();  <span class="comment">// timer will be &quot;up&quot; again exactly 1000 ms after this line...       </span></div>
<div class="line">    <span class="comment">// ...or do stuff here - this is occuring while the timer is &quot;running&quot;.  So, as long</span></div>
<div class="line">   <span class="comment">// as these steps take less time than the timer interval (1000 ms), each cycle will be the exact same</span></div>
<div class="line">    <span class="comment">// duration</span></div>
<div class="line">   }</div>
<div class="line"> }</div>
</div><!-- fragment --><p>See <a class="el" href="_flex_timer_8h.html">FlexTimer.h</a> for details on <a class="el" href="class_step_timer.html">StepTimer</a> and <a class="el" href="class_flex_timer.html">FlexTimer</a> classes. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
